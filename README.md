# Design and Manage Database for an online Grocer using Mysql Workbench

  ## *Table of Contents*
 
 1. __INTRODUCTION__
     - [Overview](#overview)
     - [Project Scenario](#project-scenario)
     - [Project Objectives](#project-objectives)
     - [Skills](#skills)
     - [Project Tools](#project-tools)
 2. __BUILD MY PROJECT__
    - [Database Design ](#database-design)
    - [Database Testing](#database-testing)
    - [Insights and Conclusions](#insights-and-conclusions)

## Overview

In this project,I stepped into the shoes of an entry-level back-end developer. I used my database design and development skills as my help to reorganize spreadsheet data into a database that supports an online grocery business as they expand their offerings.

 
 
## Project Scenario

Greenspot Grocer is a (fictional) small, family-owned online grocery store that is growing rapidly and planning a major expansion. They are currently storing their product data in a spreadsheet format that has become unwieldy and will soon be unable to accommodate their growing inventory. 
They want you, as a back-end developer, to examine their current data and design a relational database that will be able to provide the ability to organize and store current data, while providing scalability as the business expands its product offerings. 

## Project Objectives

*Build a database that can be used to store and organize the sample data from the .csv file. To do this:*

1. Examine the current data and reorganize it into relational tables using the modeling tool in MySQL Workbench.
2. Create and load the database with the sample data provided.
3. Test the database design and verify the design by generating SQL JOIN queries.


## Skills

1. Use both the visual interface and SQL development features of MySQL Workbench.
2. Analyze a dataset and design a database to store/organize its data in one or more normalized relational tables.
3. Generate an EER (Extended Entity-Relationship) Diagram using MySQL Workbench Modeling tool.
4. Create and load a multi-table database from an EER Diagram using MySQL Workbench.
5. Develop queries that access data from related database to prove the database design is viable.
6. Share findings by providing:
   - A database model (and Extended Entity-Relationship Diagram generated by the MySQL Workbench Modeling tool)
   - The database, exported as a an SQL script
   - One or more SQL queries (exported as SQL scripts) that prove your database design provides access to all related tables.
  
## Project Tools
 - Mysql
 - Microsoft Excel
 - Search Engines
 - Youtube


# HOW I BUID MY PROJECT
## Database Design

![Screenshot (105)](https://github.com/user-attachments/assets/bcf51395-bd10-4b23-b95c-a070d28d0fc7)

Based on my analysis and Examination, the Greenspot Grocer sample data is stored in a flat-file spreadsheet that tracks inventory, purchases, and sales for a grocery store. Each row represents a single transaction or update an inventory adjustment, a sale to a customer, or a purchase from a vendor with columns providing specific details about the event. The spreadsheet serves as a running log of all activities, but its structure introduces challenges that a relational database could address.


*Before we can do anything we have to define the columns*

__Column Definitions__
- __Item_num:__ A unique identifier for each item type.

- __Description:__ The product name (e.g., "Bennet Farm free-range eggs").

- __Quantity_on_hand:__ The current stock level after a transaction or update.

- __Cost:__ The price paid to the vendor for the item (typically blank for sales).

- __Purchase_date:__ The date the store acquired the item from a vendor (blank for sales).

- __Vendor:__ The supplier’s name and address (blank for sales).

- __Price:__ The selling price to customers (blank for purchases).

- __Date_sold:__ The date the item was sold to a customer (blank for purchases).

- __Cust:__ A customer ID (blank for purchases and sometimes missing entirely).

- __Quantity:__ The amount bought or sold in a transaction.

- __Item_type:__ The product category (e.g., "Dairy").

- __Location:__ The storage location within the store (e.g., "D12").

- __Unit:__ The unit of measurement (e.g., "12 oz can").



__Issues with the Current Flat-File Format__


1. __*Data Redundancy:*__ Descriptive details like Description, Item_type, Location, and Unit are repeated across rows for the same item. 
2. __*Missing Data:*__ Key fields are inconsistently populated. For instance, Cust is often blank even for sales, and Cost is sometimes missing for purchases.
3. __*Confusion in Transactions:*__ Without a clear transaction type, it's hard to tell if a row is a purchase, sale, or inventory update without checking other fields. A row with 
     Quantity but no Price or Date_Sold might be a purchase or just missing data.
4. __Formatting Inconsistencies:*__
     -  Small differences in data entry, like "12 ounce can" vs. "12 oz can" for Unit, or "D12" vs. "d12" for Location—can disrupt automated processing or searches.
     - "Cust" (short for "Customer") might confuse users unfamiliar with the abbreviation.
5. __*Scalability Limitations:*__ As the store grows, using a single spreadsheet becomes difficult. Finding total sales or profit means checking every row manually, which takes a lot of time and can lead to mistakes.

 
__Proposed Relational Database Design__

To fix these issues, Greenspot Grocer can organize its data into a structured database with separate tables. This will remove duplicate data, keep information accurate, and make it easier to grow by connecting related data efficiently.

 
1. __Items__ (Stores basic details about each item, which other tables can refer to)
   - Item_num (Primary Key)  
   - Description  
   - Item_type  
   - Location  
   - Unit
     
2. __Vendors__ (Supplier details store all vendor information in one place, preventing repetition in purchase records.)  
    - Vendor_ID (Primary Key)
    - Vendor_Name
    - Vendor_Address

3. __Purchases__ (Store’s item purchases tracks each purchase transaction from vendors)  
     - Purchase_ID (Primary Key, auto-generated)
     - Item_num (Foreign Key to Items)
     - Vendor_ID (Foreign Key to Vendors)
     - Purchase_date
     - Cost
     - Quantity_purchased
     - Quantity_on_hand
       
4. __Sales__ (Customer transactions)  
   - Sale_ID (Primary Key, auto-generated)
   - Item_num (Foreign Key to Items)
   - Customer_ID (Foreign Key to Customers)
   - Date_sold
   - Price
   - Quantity_sold
   - Quantity_on_hand

5. __Customers__ (Customer information)  
     - Customer_ID (Primary Key)  

__How it works__
      - When the store buys items, the row includes the cost, purchase date, vendor, and updates the quantity on-hand.
      - When items are sold , the row lists the price, date sold, customer ID, quantity sold, and adjusts the quantity on-hand downward.

__Relationships__

   __> Items to Sales:__ One item can be sold multiple times (1-to-many). Linked via Item_num.

  __> Items to Purchases:__ One item can be purchased multiple times (1-to-many). Linked via Item_num.

   __> Vendors to Purchases:__ One vendor can supply many purchases (1-to-many). Linked via Vendor_ID.

   __> Customers to Sales:__ One customer can make multiple purchases over time (1-to-many). Linked via Customer_ID.


__Benefits of the Relational Database I  Designed__

1. Item details are stored once in the tables, not repeated across transactions.
2. Foreign keys enforce consistency (e.g., only valid Item_num values are used).
3. Separate Purchases and Sales tables eliminate ambiguity.
4. Queries become faster and more efficient using relational joins.
5. Standardized fields
   
__EXTENDED ENTITY RELATION DIAGRAM__
   - To create this EERD I used mySQL Data Modelling tool
   - After completing the EERD I used foward engineering option to create a schema/daabase

 ![EXTENDED ENTITY RELATION DIAGRAM](https://github.com/user-attachments/assets/6c53aa2c-8ff9-456c-a170-d3f718497618)


## Database Testing

Once I’ve created the EERD and built the database, the first step was to insert the data from the data file into the newly created tables. After that, I tested the relationships between the tables using a variety of SQL queries. First, I demonstrated that I can retrieve data from every table in the database with just one query. Then, I wrote one or more queries that show how I can join tables together, including the SQL code to prove it works. Lastly I created queries that answers bussiness questions to prove that it works

1. __Insert data from the  Greenspoot Grocer data file into the created database tables__

``` sql
-- INSERTING DATA INTO ITEMS TABLE

INSERT INTO mydb.items (Item_Num, Description, Item_Type, Location, Unit)
VALUES
(1000, 'Bennet Farm free-range eggs', 'Dairy', 'D12', 'dozen'),
(1100, 'Freshness White beans', 'Canned', 'a2', '12 oz can'),
(1222, 'Freshness Green beans', 'Canned', 'a3', '12-oz can'),
(1223, 'Freshness Green beans', 'Canned', 'a7', '36 oz can'),
(1224, 'Freshness Wax beans', 'Canned', 'a3', '12-oz can'),
(2000, 'Ruby''s Kale', 'Produce', 'p12', 'bunch'),
(2001, 'Ruby''s Organic Kale', 'Produce', 'po2', 'bunch');

--INSERTING DATA INTO VENDORS TABLE

INSERT INTO mydb.vendors (Vendor_ID, Vendor_Name, Vendor_Address)
VALUES
('V001', 'Bennet Farms', 'Rt. 17 Evansville, IL 55446'),
('V002', 'Freshness, Inc.', '202 E. Maple St., St. Joseph, MO 45678'),
('V003', 'Ruby Redd Produce, LLC', '1212 Milam St., Kenosha, AL 34567');

-- INSERTING DATA INTO CUSTOMERS TABLE

INSERT INTO mydb.customers (Customer_ID)
VALUES
(198765),
(202900),
(196777),
(277177),
(111000),
(100988);

-- INSERTING DATA INTO SALES TABLE, 0 IS USED FOR NULL CUSTOMER IDs

INSERT INTO mydb.sales (Item_Num, Customer_ID, Quantity_On_Hand, Price, Date_Sold, Quantity_Sold)
VALUES
(1000, 198765, 27, 5.49, '2022-02-02', 2),
(2000, 0, 3, 3.99, '2022-02-02', 2),
(1100, 202900, 13, 1.49, '2022-02-02', 2),
(1000, 196777, 25, 5.99, '2022-02-04', 2),
(1100, 198765, 45, 1.49, '2022-02-07', 8),
(1000, 277177, 21, 5.49, '2022-02-11', 4),
(1100, 0, 41, 1.49, '2022-02-11', 4),
(1222, 111000, 47, 1.29, '2022-02-12', 12),
(1224, 0, 23, 1.55, '2022-02-12', 8),
(1223, 198765, 7, 3.49, '2022-02-13', 5),
(2001, 100988, 19, 6.99, '2022-02-13', 1),
(2001, 202900, 7, 6.99, '2022-02-14', 12),
(2000, 111000, 26, 3.99, '2022-02-15', 2);


--INSERTING DATA INTO PURCHASES TABLE

INSERT INTO mydb.purchases (Vendor_ID, Item_Num, Quantity_On_Hand, Cost, Purchase_Date, Quantity_Purchased)
VALUES
('V001', 1000, 29, 2.35, '2022-02-01', 25),
('V002', 1100, 53, 0.69, '2022-02-02', 40),
('V002', 1222, 59, 0.59, '2022-02-10', 40),
('V002', 1223, 12, 1.75, '2022-02-10', 10),
('V002', 1224, 31, 0.65, '2022-02-10', 30),
('V003', 2000, 28, 1.29, '2022-02-12', 25),
('V003', 2001, 20, 2.19, '2022-02-12', 20),
('V002', 1223, 17, 1.8, '2022-02-15', 10);

```

2. __Retrieve data from every table in the created database__

- *__Retreive from items Table__*

![Screenshot (99)](https://github.com/user-attachments/assets/5295e69e-f7cb-4d33-8f6e-809a392bd8eb)

 
-  *__Retreive from vendors Table__*

![Screenshot (100)](https://github.com/user-attachments/assets/7f65bf3c-5453-41b9-871f-089832a9c92e)

-  *__Retreive from customers Table__*

![Screenshot (102)](https://github.com/user-attachments/assets/5251db77-77cf-40e0-9274-0f80d9e15019)

-  *__Retreive from sales Table__*

![Screenshot (103)](https://github.com/user-attachments/assets/0e50e5d2-bd6a-4637-a1ba-b33219d0e47b)

-  *__Retreive from purchases Table__*
    
![Screenshot (104)](https://github.com/user-attachments/assets/5a02a151-19ad-4e3b-8642-b5033c7b5091)



2. __Join tables together__ 

Single SQL cript to join all the created tables  

 ``` sql
SELECT
    i.Item_Num,
    i.Item_Description,
    i.Item_Type,
    i.Location,
    i.unit,
    p.Purchases_ID,
    p.Quantity_on_Hand AS Purchase_Quantity_On_Hand,
    p.Cost,
    p.Purchase_Date,
    p.Quantity_Bought,
    s.Sales_ID,
     c.Customer_ID,
    s.Quantity_on_Hand AS Sales_Quantity_On_Hand,
    s.Price,
    s.Date_Sold,
    s.Quantity_Sold,
    v.Vendor_ID,
    v.Vendor_Name,
    v.Address
FROM sales s
JOIN customers c ON s.Customers_Customer_ID = c.Customer_ID
JOIN items i ON s.Items_Item_Num = i.Item_Num
LEFT JOIN purchases p ON i.Item_Num = p.Items_Item_Num
LEFT JOIN vendors v ON p.Vendors_Vendor_ID = v.Vendor_ID;
```
3. __Write queries to answer business questions__

Which items are running low and need restocking, and which products are overstocked and tying up capital?

``` sql

SELECT  Item_Description, Item_Type , Quantity_on_Hand from mydb.items 
join 
sales  on Items_Item_Num=Item_Num
where Quantity_on_Hand < 10 ORDER BY  Quantity_on_Hand ASC;


SELECT  Item_Description, Item_Type , Quantity_on_Hand from mydb.items 
join 
sales  on Items_Item_Num=Item_Num
where Quantity_on_Hand > 30 ORDER BY  Quantity_on_Hand DESC;

```


What’s the total value of our current inventory?
``` sql

SELECT SUM(Price *  Quantity_on_Hand) AS TotalInventoryValue FROM mydb.sales;
```

Which products are the top sellers by volume or revenue?
```sql

 SELECT 
 Item_Description, SUM(Quantity_Sold) AS TotalSold
FROM
    mydb.items
        JOIN
    Sales  ON  Items_Item_Num =  Item_Num
GROUP BY  Item_Description
ORDER BY TotalSold DESC
LIMIT 5;

-- Revenue

 SELECT 
 Item_Description, SUM(Quantity_Sold* Price) AS TotalSold
FROM
    mydb.items
        JOIN
    Sales  ON  Items_Item_Num =  Item_Num
GROUP BY  Item_Description
ORDER BY TotalSold DESC
LIMIT 5;

```

Which items are bought most

``` sql

 SELECT 
    Vendors_Vendor_ID, 
    Vendor_Name, 
    COUNT(Items_Item_Num) AS Total_Items_Bought
FROM purchases 
JOIN vendors  ON Vendors_Vendor_ID = Vendor_ID
GROUP BY Vendors_Vendor_ID, Vendor_Name
ORDER BY Total_Items_Bought DESC
LIMIT 1;
```
 
 
Who are our most frequent or highest-spending customers?

 ```sql


SELECT 
    c.Customer_ID, 
    COUNT(s.Sales_ID) AS PurchaseCount, 
    SUM(s.Quantity_Sold * s.Price) AS TotalSpent
FROM customers c
JOIN sales s ON c.Customer_ID = s.Customers_Customer_ID
JOIN items i ON s.Items_Item_Num = i.Item_Num
GROUP BY c.Customer_ID
ORDER BY TotalSpent DESC
LIMIT 5;
```


 ## Insights and Conclusions

__Explanation of How the Database Design Addresses Issues that Greenspot Grocer had__

1. __*Eliminating Redundancy:*__ By using separate tables for each entity, data is stored only once, reducing duplication and making updates more efficient.
2. __*Handling Missing Data:*__ During Excel data cleaning, gaps were addressed—missing customer numbers were set to 0, and incomplete entries were flagged—before importing into MySQL.
3. __*Standardizing Formatting:*__ The abbreviation "cust" was changed to "customer" to ensure clarity and make the data understandable for everyone.
4. __*Establishing Relationships:*__ Foreign keys create logical, enforceable connections between tables, ensuring the data is linked correctly.
5. __*Enforcing Integrity and Scalability:*__ This design prevents duplicates and ensures data integrity, while the relational model supports future growth. New products or suppliers 
                                              can be added seamlessly without needing to restructure.



__How does the Database Design Support Business Growth__

The database is designed to handle more data smoothly and is easily adaptable as the business expands.

- The relational structure allows for seamless addition of new items, vendors, and customers without major modifications.  
- The separation of items, purchases, sales, and vendors ensures that new product categories can be introduced without disrupting existing records. The JOIN-based relationships allow 
  easy reporting and tracking across various product lines.
– Foreign keys and constraints maintain accurate relationships, preventing data inconsistencies as more transactions occur.
– The design supports trend analysis, stock management, and customer insights, enabling informed decision-making as the business scales.

__Future Enhancements for a More Valuable Database__

- **Vendor Relationship Management** – Expanding the Vendors table to include contact details, payment terms, and performance ratings will improve vendor management
- **Customer Profiles and Loyalty Tracking**-  Expanding the Customers table to include Customer_ID, Customer_Name, Email, and Address will enable personalized marketing and efficient 
                                               delivery logistics. This enhances customer engagement, supports loyalty programs, and improves retention as the business scales


## THE END

 


