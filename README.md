# Design and Manage Database for an online Grocer using Mysql Workbench

  ## *Table of Contents*
 
 1. __INTRODUCTION__
     - [Overview](#overview)
     - [Project Scenario](#project-scenario)
     - [Project Objectives](#project-objectives)
     -  [My Task](#my-task)
     - [Skills](#skills)
     - [Project Tools](#project-tools)
 2. __BUILD MY PROJECT__
   - [Database Design Analysis: ](#database-design-analysis)

## Overview

In this project,I stepped into the shoes of an entry-level back-end developer. I used my database design and development skills as my help to reorganize spreadsheet data into a database that supports an online grocery business as they expand their offerings.

 
 
## Project Scenario

Greenspot Grocer is a (fictional) small, family-owned online grocery store that is growing rapidly and planning a major expansion. They are currently storing their product data in a spreadsheet format that has become unwieldy and will soon be unable to accommodate their growing inventory. 
They want you, as a back-end developer, to examine their current data and design a relational database that will be able to provide the ability to organize and store current data, while providing scalability as the business expands its product offerings. 

## Project Objectives

1. Examine the current data and reorganize it into relational tables using the modeling tool in MySQL Workbench.
2. Create and load the database with the sample data provided.
3. Test the database design and verify the design by generating SQL JOIN queries.
   
## My Task

__Build a database that can be used to store and organize the sample data from the .csv file. To do this, you will:__
- Explore the sample data, looking for fields that should be grouped together in tables.
- Then identify logical relationships among those tables.
- Use the Modeling tool in MySQL Workbench to generate a database model that includes tables, with their fields, and shows relationships between tables with primary keys, and foreign 
  keys where applicable.
- Implement your database design in MySQL Workbench by creating the database and its tables and populating the tables with the sample data provided.
- You will also generate SQL JOIN queries to prove the validity of your database design by proving that data can be retrieved from multiple tables in a single query.


## Skills

1. Use both the visual interface and SQL development features of MySQL Workbench.
2. Analyze a dataset and design a database to store/organize its data in one or more normalized relational tables.
3. Generate an EER (Extended Entity-Relationship) Diagram using MySQL Workbench Modeling tool.
4. Create and load a multi-table database from an EER Diagram using MySQL Workbench.
5. Develop queries that access data from related database to prove the database design is viable.
6. After you perform your analysis, you will share your findings by providing:
   - A database model (and Extended Entity-Relationship Diagram generated by the MySQL Workbench Modeling tool)*
   - The database, exported as a an SQL script*
   - One or more SQL queries (exported as SQL scripts) that prove your database design provides access to all related tables.
  

## Project Tools
 - Mysql
 - Excel
 - Google Chrome
 - Youtube


# HOW I BUID MY PROJECT

## Database Design Analysis

Based on my analysis, the Grocer sample data is stored in a flat-file spreadsheet that tracks inventory, purchases, and sales for a grocery store. Each row represents a single transaction or update an inventory adjustment, a sale to a customer, or a purchase from a vendor with columns providing specific details about the event. The spreadsheet serves as a running log of all activities, but its structure introduces challenges that a relational database could address.

__Column Definitions__

 
 *The columns in the spreadsheet appear to be as follows:*
- __Item_num:__ A unique identifier for each item type.

- __Description:__ The product name (e.g., "Bennet Farm free-range eggs").

- __Quantity_on_hand:__ The current stock level after a transaction or update.

- __Cost:__ The price paid to the vendor for the item (typically blank for sales).

- __Purchase_date:__ The date the store acquired the item from a vendor (blank for sales).

- __Vendor:__ The supplier’s name and address (blank for sales).

- __Price:__ The selling price to customers (blank for purchases).

- __Date_sold:__ The date the item was sold to a customer (blank for purchases).

- __Cust:__ A customer ID (blank for purchases and sometimes missing entirely).

- __Quantity:__ The amount bought or sold in a transaction.

- __Item_type:__ The product category (e.g., "Dairy").

- __Location:__ The storage location within the store (e.g., "D12").

- __Unit:__ The unit of measurement (e.g., "12 oz can").
 

__How the Data Works__

__> Purchases:__ When the store acquires __*items*__, the row includes __*Cost*__ , __*Purchase_date*__  , __*Vendor*__ , and __*Quantity*__ , and updates __*Quantity_on_hand*__ to reflect the new stock level.*

__> Sales:__ When items are sold, the row lists __*Price*__ , __*Date_sold*__, __*Cust*__ , and __*Quantity*__ , reducing __*Quantity_on_hand*__ accordingly.


__Potential Issues with the Current Flat-File Format__


1. __*Data Redundancy:*__ Descriptive details like Description, Item_type, Location, and Unit are repeated across rows for the same item. For example, "Bennet Farm free-range eggs" might appear multiple times with identical metadata. This wastes storage space and risks inconsistencies (e.g., a typo in one row’s Description).

2. __*Missing Data:*__ Key fields are inconsistently populated. For instance, Cust is often blank even for sales, and Cost is sometimes missing for purchases. This hinders tracking of customer activity or accurate cost analysis.

3. __*Ambiguity in Transactions:*__ Without a dedicated transaction-type indicator, it’s unclear whether a row represents a purchase, sale, or inventory update without cross-referencing fields. A row with Quantity but no Price or Date_sold could be a purchase—or simply incomplete.

4. __Formatting Inconsistencies:*__ Small variations in data entry—such as "12 ounce can" vs. "12 oz can" for Unit, or "D12" vs. "d12" for Location—can disrupt automated processing or searches. Additionally, "Cust" (short for "Customer") might confuse users unfamiliar with the abbreviation.

5. __*Scalability Limitations:*__ As the store’s operations grow, managing all data in a single spreadsheet becomes impractical. Tasks like calculating total sales for an item or determining profit require manually sifting through every row, which is time-consuming and error-prone.


 
__Proposed Relational Database Design__

To address these issues, the flat-file data can be restructured into a relational database with separate tables. This design eliminates redundancy, improves data integrity, and enhances scalability by organizing data into logical entities and defining relationships between them.

 
1. __Items__ (Core product information)
   - Item_num (Primary Key)  
   - Description  
   - Item_type  
   - Location  
   - Unit
Purpose: Stores static details about each unique item, referenced by other tables.

2. __Vendors__ (Supplier details)  
    - Vendor_ID (Primary Key)
    - Vendor_Name
    - Vendor_Address
Purpose: Centralizes vendor information to avoid repetition in purchase records.

3. __Purchases__ (Store’s item acquisitions)  
     - Purchase_ID (Primary Key, auto-generated)
     - Item_num (Foreign Key to Items)
     - Vendor_ID (Foreign Key to Vendors)
     - Purchase_date
     - Cost
     - Quantity_purchased
     - Quantity_on_hand
Purpose: Tracks each purchase transaction and its impact on inventory.

4. __Sales__ (Customer transactions)  
   - Sale_ID (Primary Key, auto-generated)
   - Item_num (Foreign Key to Items)
   - Customer_ID (Foreign Key to Customers)
   - Date_sold
   - Price
   - Quantity_sold
   - Quantity_on_hand
Purpose: Records sales data and updates inventory levels.

5. __Customers__ (Customer information)  
     - Customer_ID (Primary Key)  

__Relationships__

   __> Items to Sales:__ One item can be sold multiple times (1-to-many). Linked via Item_num.

  __> Items to Purchases:__ One item can be purchased multiple times (1-to-many). Linked via Item_num.

   __> Vendors to Purchases:__ One vendor can supply many purchases (1-to-many). Linked via Vendor_ID.

   __> Customers to Sales:__ One customer can make multiple purchases over time (1-to-many). Linked via Customer_ID.


__Benefits of the Relational Design__

1. __Reduced Redundancy:__ Item details are stored once in the Items table, not repeated across transactions.
2. __Improved Data Integrity:__  Foreign keys enforce consistency (e.g., only valid Item_num values are used).
3. __Clear Transaction Types:__ Separate Purchases and Sales tables eliminate ambiguity.
4. __Scalability:__ Queries (e.g., total sales per item) become faster and more efficient using relational joins.
5. ___Consistency:__ Standardized fields (e.g., Unit) can be enforced at the database level.

__EXTENDED ENTITY RELATION DIAGRAM__
   - To create it I used mySQL Data Modelling tool

 ![EXTENDED ENTITY RELATION DIAGRAM](https://github.com/user-attachments/assets/6c53aa2c-8ff9-456c-a170-d3f718497618)



## Database Testing

Once I’ve created the ERD and built the database, I’ll start by inserting the data from the flat file into the newly created tables. After that, I’ll test the relationships between the tables using a variety of SQL queries. First, I’ll demonstrate that I can retrieve data from every table in the database with just one query. Then, I’ll write one or more queries that show how I can join tables together, including the SQL code to prove it works. Finally, queries that answers bussiness questions  to prove that it works
1. __Insert data from the csv into the created database tables__

``` sql
-- INSERTING DATA INTO ITEMS TABLE

INSERT INTO mydb.items (Item_Num, Description, Item_Type, Location, Unit)
VALUES
(1000, 'Bennet Farm free-range eggs', 'Dairy', 'D12', 'dozen'),
(1100, 'Freshness White beans', 'Canned', 'a2', '12 oz can'),
(1222, 'Freshness Green beans', 'Canned', 'a3', '12-oz can'),
(1223, 'Freshness Green beans', 'Canned', 'a7', '36 oz can'),
(1224, 'Freshness Wax beans', 'Canned', 'a3', '12-oz can'),
(2000, 'Ruby''s Kale', 'Produce', 'p12', 'bunch'),
(2001, 'Ruby''s Organic Kale', 'Produce', 'po2', 'bunch');

--INSERTING DATA INTO VENDORS TABLE

INSERT INTO mydb.vendors (Vendor_ID, Vendor_Name, Vendor_Address)
VALUES
('V001', 'Bennet Farms', 'Rt. 17 Evansville, IL 55446'),
('V002', 'Freshness, Inc.', '202 E. Maple St., St. Joseph, MO 45678'),
('V003', 'Ruby Redd Produce, LLC', '1212 Milam St., Kenosha, AL 34567');

-- INSERTING DATA INTO CUSTOMERS TABLE

INSERT INTO mydb.customers (Customer_ID)
VALUES
(198765),
(202900),
(196777),
(277177),
(111000),
(100988);

-- INSERTING DATA INTO SALES TABLE, 0 IS USED FOR NULL CUSTOMER IDs

INSERT INTO mydb.sales (Item_Num, Customer_ID, Quantity_On_Hand, Price, Date_Sold, Quantity_Sold)
VALUES
(1000, 198765, 27, 5.49, '2022-02-02', 2),
(2000, 0, 3, 3.99, '2022-02-02', 2),
(1100, 202900, 13, 1.49, '2022-02-02', 2),
(1000, 196777, 25, 5.99, '2022-02-04', 2),
(1100, 198765, 45, 1.49, '2022-02-07', 8),
(1000, 277177, 21, 5.49, '2022-02-11', 4),
(1100, 0, 41, 1.49, '2022-02-11', 4),
(1222, 111000, 47, 1.29, '2022-02-12', 12),
(1224, 0, 23, 1.55, '2022-02-12', 8),
(1223, 198765, 7, 3.49, '2022-02-13', 5),
(2001, 100988, 19, 6.99, '2022-02-13', 1),
(2001, 202900, 7, 6.99, '2022-02-14', 12),
(2000, 111000, 26, 3.99, '2022-02-15', 2);


--INSERTING DATA INTO PURCHASES TABLE

INSERT INTO mydb.purchases (Vendor_ID, Item_Num, Quantity_On_Hand, Cost, Purchase_Date, Quantity_Purchased)
VALUES
('V001', 1000, 29, 2.35, '2022-02-01', 25),
('V002', 1100, 53, 0.69, '2022-02-02', 40),
('V002', 1222, 59, 0.59, '2022-02-10', 40),
('V002', 1223, 12, 1.75, '2022-02-10', 10),
('V002', 1224, 31, 0.65, '2022-02-10', 30),
('V003', 2000, 28, 1.29, '2022-02-12', 25),
('V003', 2001, 20, 2.19, '2022-02-12', 20),
('V002', 1223, 17, 1.8, '2022-02-15', 10);

```

2. __Retrieve data from every table in the database__

- *__Retreive from items Table__*

![Screenshot (99)](https://github.com/user-attachments/assets/5295e69e-f7cb-4d33-8f6e-809a392bd8eb)

 
-  *__Retreive from vendors Table__*

![Screenshot (100)](https://github.com/user-attachments/assets/7f65bf3c-5453-41b9-871f-089832a9c92e)

-  *__Retreive from customers Table__*

![Screenshot (102)](https://github.com/user-attachments/assets/5251db77-77cf-40e0-9274-0f80d9e15019)

-  *__Retreive from sales Table__*

![Screenshot (103)](https://github.com/user-attachments/assets/0e50e5d2-bd6a-4637-a1ba-b33219d0e47b)

-  *__Retreive from purchases Table__*
    
![Screenshot (104)](https://github.com/user-attachments/assets/5a02a151-19ad-4e3b-8642-b5033c7b5091)



2. __Join tables together__ 

 ``` sql
      i.Item_Num,
    i.Item_Description,
    i.Item_Type,
    i.Location,
    i.unit,
    p.Purchases_ID,
    p.Quantity_on_Hand AS Purchase_Quantity_On_Hand,
    p.Cost,
    p.Purchase_Date,
    p.Quantity_Bought,
    s.Sales_ID,
     c.Customer_ID,
    s.Quantity_on_Hand AS Sales_Quantity_On_Hand,
    s.Price,
    s.Date_Sold,
    s.Quantity_Sold,
    v.Vendor_ID,
    v.Vendor_Name,
    v.Address
FROM sales s
JOIN customers c ON s.Customers_Customer_ID = c.Customer_ID
JOIN items i ON s.Items_Item_Num = i.Item_Num
LEFT JOIN purchases p ON i.Item_Num = p.Items_Item_Num
LEFT JOIN vendors v ON p.Vendors_Vendor_ID = v.Vendor_ID;
```
3. __Write queries to answer business questions__

Which Items are running low and need restocking

 

Which products are overstocked and tying up capital?
Why: Frees up resources by identifying slow-moving items for discounts or reduced ordering.
SQL: SELECT ProductName, StockQuantity FROM Products WHERE StockQuantity > 100 ORDER BY StockQuantity DESC;

What’s the total value of our current inventory?
Why: Helps assess financial health and plan purchasing budgets.
SQL: SELECT SUM(Price * StockQuantity) AS TotalInventoryValue FROM Products;


Which products are the top sellers by volume or revenue?
Why: Highlights popular items to prioritize in marketing or stock planning.
SQL (Volume): SELECT p.ProductName, SUM(s.QuantitySold) AS TotalSold FROM Products p JOIN Sales s ON p.ProductID = s.ProductID GROUP BY p.ProductName ORDER BY TotalSold DESC LIMIT 5;


SQL (Revenue): SELECT p.ProductName, SUM(s.QuantitySold * p.Price) AS TotalRevenue FROM Products p JOIN Sales s ON p.ProductID = s.ProductID GROUP BY p.ProductName ORDER BY TotalRevenue DESC LIMIT 5;

Which categories are driving the most sales?
Why: Guides category expansion or layout decisions for the online store.
SQL: SELECT c.CategoryName, SUM(s.QuantitySold) AS TotalSold FROM Categories c JOIN Products p ON c.CategoryID = p.CategoryID JOIN Sales s ON p.ProductID = s.ProductID GROUP BY c.CategoryName ORDER BY TotalSold DESC;

Who are our most frequent or highest-spending customers?
Why: Identifies loyal customers for targeted promotions or loyalty programs.
SQL: SELECT c.CustomerName, COUNT(s.SaleID) AS PurchaseCount, SUM(s.QuantitySold * p.Price) AS TotalSpent FROM Customers c JOIN Sales s ON c.CustomerID = s.CustomerID JOIN Products p ON s.ProductID = p.ProductID GROUP BY c.CustomerName ORDER BY TotalSpent DESC LIMIT 5;






 


